local knit = require("knit")

function sel(cond, t, f)
    if cond then return t else return f end
end

local prefix = "riscv64-unknown-elf"

local conf = {
    dc = cli.dc or "ldc",
    board = cli.board or "qemuvirt",
    ncpu = 4,
}

local machines = {
    qemuvirt = {
        board = "qemuvirt",
        mabi = "lp64",
        march = "rv64ima",
        arch = "riscv64",
        mcmodel = "medany",
        qemu = "virt",
        ncpu = conf.ncpu,
    },
    visionfive = {
        board = "visionfive",
        mabi = "lp64",
        march = "rv64ima",
        arch = "riscv64",
        mcmodel = "medany",
        qemu = "virt",
        ncpu = 2,
    }
}

local machine = machines[conf.board]

if machine.mcmodel == "medany" then
    machine.cmodel = "medium"
else
    machine.cmodel = "small"
end

local tools = {
    dc = sel(conf.dc == "gdc", f"$prefix-gdc", "ldc2"),
    cc := $prefix-gcc
    as := $prefix-as
    ld := $prefix-ld
    cpp := $prefix-cpp
    objcopy := $prefix-objcopy
    objdump := $prefix-objdump
    gdb := $prefix-gdb
    qemu := qemu-system-$(machine.arch)
}

local flags = {
    dc = sel(
        conf.dc == "gdc",
        f"-fno-exceptions -fno-rtti -O3 -nostartfiles -nostdlib -mabi=$(machine.mabi) -march=$(machine.march) -mcmodel=$(machine.mcmodel) -ffunction-sections -fdata-sections",
        f"--betterC -Oz -gc -mtriple=$prefix -mattr=+m,+a,+relax -platformlib= --code-model=$(machine.cmodel) --function-sections --data-sections --fthread-model=local-exec --d-version=$(machine.board)"
    ),
    as := -mabi=$(machine.mabi) -march=$(machine.march) -mcmodel=$(machine.mcmodel)
    ld := -nostartfiles -mcmodel=$(machine.mcmodel) -Wl,--gc-sections
    qemu := -bios ../opensbi_step/build/platform/generic/firmware/fw_jump.bin -smp $(machine.ncpu) -machine $(machine.qemu) -m 2G -nographic
}

local meta = r{
    $ %.o: %.s
        $(tools.cc) $(flags.as) -xassembler-with-cpp $input -c -o $output
    $ %.bin: %.elf
        $(tools.objcopy) $input -O binary $output
    $ %.list: %.elf
        $(tools.objdump) -D $input > $output
}

local lib = knit.rglob("libd", "*.d")

local kern = knit.join(
    knit.filterout(knit.rglob(f"kernel/arch/$(machine.arch)", "*.d"), {f"kernel/arch/$(machine.arch)/boot.d"}),
    knit.rglob(f"kernel/board/$(machine.board)", "*.d"),
    knit.rglob("kernel/dev", "*.d"),
    knit.glob("kernel/*.d")
)

local boot = knit.join(
    knit.rglob(f"kernel/arch/$(machine.arch)", "*.d"),
    {
        "kernel/init.d",
        "kernel/sys.d",
        "kernel/vm.d",
        "kernel/arch/package.d",
    }
)

local bootloader = knit.join(
    knit.filterout(knit.rglob(f"kernel/arch/$(machine.arch)", "*.d"), {f"kernel/arch/$(machine.arch)/boot.d"}),
    knit.rglob(f"kernel/board/$(machine.board)", "*.d"),
    knit.rglob("kernel/dev", "*.d"),
    knit.rglob("bootloader", "*.d"),
    {
        "kernel/sys.d",
        "kernel/arch/package.d",
    }
)

local kernobj = {
    "kernel.o",
    "libd.o",
    f"kernel/arch/$(machine.arch)/kernelstart.o",
    f"kernel/arch/$(machine.arch)/kernelvec.o",
    f"kernel/arch/$(machine.arch)/uservec.o",
}

local bootobj = {
    "boot.o",
    "libd.o",
    f"kernel/arch/$(machine.arch)/bootstart.o",
}

local bootloaderobj = {
    "bootloader.o",
    "libd.o",
    f"kernel/arch/$(machine.arch)/bootstart.o",
}

local dco = sel(conf.dc == "gdc", "o", "of")

local link = {
    kernel = "link/kernel.ld",
    boot = "link/boot.ld",
    bootloader = "link/bootloader.ld",
}

local kernel = r{
    $ libd.o: $lib
        $(tools.dc) $(flags.dc) -Ikernel -Ilibd $input -c -$dco $output
    $ kernel.o: $kern libd[I]
        $(tools.dc) $(flags.dc) -Ikernel -Ilibd -J. $input -c -$dco $output
    $ boot.o: $boot libd[I] kernel.bin[I]
        $(tools.dc) $(flags.dc) -Ikernel -Ilibd -J. $input -c -$dco $output
    $ boot.elf: $bootobj $(link.boot)[I]
        $(tools.cc) $(flags.as) $(flags.ld) -T$(link.boot) $input -lgcc -o $output
    $ bootloader.o: $bootloader libd[I]
        $(tools.dc) $(flags.dc) --d-version=baremetal -Ikernel -Ilibd $input -c -$dco $output
    $ bootloader.elf: $bootloaderobj $(link.bootloader)[I]
        $(tools.cc) $(flags.as) $(flags.ld) -T$(link.bootloader) $input -lgcc -o $output
    $ kernel.elf: $kernobj $(link.kernel)[I]
        $(tools.cc) $(flags.as) $(flags.ld) -T$(link.kernel) $input -lgcc -o $output
    $ qemu:VB: boot.elf
        $(tools.qemu) $(flags.qemu) -kernel $input
    $ qemu-gdb:VBQ: boot.elf
        $(tools.qemu) $(flags.qemu) -s -S -kernel $input &
        $(tools.gdb) -ex "file kernel.elf" -ex "target remote localhost:1234"
}

local allsrc = knit.rglob(".", "*.d")

return b{
    $ all:V: kernel.elf kernel.list kernel.bin boot.list boot.bin

    $ bootloader:V: bootloader.bin

    $ format:VB:
        dfmt -i --brace_style=otbs $allsrc
    $ clean:VB:
        knit :all -t clean
    $ prog:VB: boot.bin
        piprog boot.bin

    kernel,
    meta
}
