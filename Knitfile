local knit = require("knit")

function sel(cond, t, f)
    if cond then return t else return f end
end

local prefix = "riscv64-unknown-elf"

local conf = {
    dc = cli.dc or "ldc",
}

local machine = {
    board = "virt",
    mabi = "lp64",
    march = "rv64imac",
    arch = "riscv64",
    mcmodel = "medany",
}

if machine.mcmodel == "medany" then
    machine.cmodel = "medium"
else
    machine.cmodel = "small"
end

local tools = {
    dc = sel(conf.dc == "gdc", f"$prefix-gdc", "ldc2"),
    cc := $prefix-gcc
    as := $prefix-as
    ld := $prefix-ld
    cpp := $prefix-cpp
    objcopy := $prefix-objcopy
    objdump := $prefix-objdump
    gdb := $prefix-gdb
    qemu := qemu-system-$(machine.arch)
}

local flags = {
    dc = sel(
        conf.dc == "gdc",
        f"-fno-exceptions -fno-rtti -O3 -nostartfiles -nostdlib -mabi=$(machine.mabi) -march=$(machine.march) -mcmodel=$(machine.mcmodel) -ffunction-sections -fdata-sections",
        f"--betterC -O3 -g -mtriple=$prefix -mattr=+m,+a,+c,+relax -platformlib= --code-model=$(machine.cmodel) --function-sections --data-sections"
    ),
    as := -mabi=$(machine.mabi) -march=$(machine.march) -mcmodel=$(machine.mcmodel)
    ld := -nostartfiles -mcmodel=$(machine.mcmodel) -Wl,--gc-sections
}

local meta = r{
    $ %.o: %.s
        $(tools.cc) $(flags.as) -xassembler-with-cpp $input -c -o $output
    $ %.bin: %.elf
        $(tools.objcopy) $input -O binary $output
    $ %.list: %.elf
        $(tools.objdump) -D $input > $output
}

local kern = knit.rglob("kernel", "*.d")
local lib = knit.rglob("libd", "*.d")
local boot = knit.rglob("boot", "*.d") + knit.rglob("kernel/arch/riscv", "*.d")
local dco = sel(conf.dc == "gdc", "o", "of")

local link = {
    kernel = "kernel/link.ld",
    boot = "boot/link.ld",
}

local kernel = r{
    $ libd.o: $lib
        $(tools.dc) $(flags.dc) -Ikernel -Ilibd $input -c -$dco $output
    $ kernel.o: $kern libd[I]
        $(tools.dc) $(flags.dc) -Ikernel -Ilibd $input -c -$dco $output
    $ boot.o: $boot libd[I] kernel.bin[I]
        $(tools.dc) $(flags.dc) -Iboot -Ikernel -Ilibd -J. $input -c -$dco $output
    $ boot.elf: boot.o libd.o boot/start.o kernel/arch/riscv/timervec.o $(link.boot)[I]
        $(tools.cc) $(flags.as) $(flags.ld) -T$(link.boot) $input -lgcc -o $output
    $ kernel.elf: kernel.o libd.o kernel/start.o kernel/arch/riscv/trapvec.o $(link.kernel)[I]
        $(tools.cc) $(flags.as) $(flags.ld) -T$(link.kernel) $input -lgcc -o $output
    $ qemu:VB: boot.elf
        $(tools.qemu) -machine $(machine.board) -nographic -kernel $input -bios none
    $ qemu-gdb:VBQ: boot.elf
        $(tools.qemu) -s -S -machine $(machine.board) -nographic -kernel $input -bios none &
        $(tools.gdb) -ex "file kernel.elf" -ex "target remote localhost:1234"
}

return b{
    $ all: kernel.elf kernel.list kernel.bin boot.list boot.bin

    kernel,
    meta
}
