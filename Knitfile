local knit = require("knit")

function getopt(profile)
    if profile == "dev" then
        return {
            level = "O1",
            lto = false,
        }
    elseif profile == "debug" then
        return {
            level = "Og",
            lto = false,
        }
    elseif profile == "unopt" then
        return {
            level = "O0",
            lto = false,
        }
    elseif profile == "release" then
        return {
            level = "O3",
            lto = true,
        }
    elseif profile == "small" then
        return {
            level = "Os",
            lto = true,
        }
    end
end

local machines = {
    raspi3 = {
        arch = "aarch64",
        triple = "aarch64-none-elf",
        board = "raspi3",
        march = "armv8-a+crc",
        mcpu = "cortex-a53",
        mattr = "-sve,-fp-armv8",
        mflags = "-mgeneral-regs-only",
        qemu = "qemu-system-aarch64 -M raspi3ap -serial null -serial mon:stdio",
    },
    virt_riscv64 = {
        arch = "riscv64",
        triple = "riscv64-unknown-elf",
        board = "virt_riscv64",
        mabi = "lp64",
        march = "rv64imac_zicsr_zifencei",
        mattr = "+m,+a,+c,+relax",
        mflags = "",
        mcmodel = "medany",
        cmodel = "medium",
        qemu = "qemu-system-riscv64 -M virt -bios none -smp 4 -m 2G",
    },
    visionfive2 = {
        arch = "riscv64",
        triple = "riscv64-unknown-elf",
        board = "visionfive2",
        mabi = "lp64",
        march = "rv64imac_zicsr_zifencei",
        mattr = "+m,+a,+c,+relax",
        mflags = "",
        mcmodel = "medany",
        cmodel = "medium",
        qemu = "qemu-system-riscv64 -M visionfive2 -bios none -smp 4 -m 2G",
    }
}

local _, uconf = pcall(include, "build/conf.knit")
conf = {
    board = choose(cli.board, uconf.board, "virt_riscv64"),
    profile = choose(cli.profile, uconf.profile, "dev"),
    unified = choose(cli.unified, uconf.unified, false),
    dc = choose(cli.dc, uconf.dc, "ldc"),
}

function makedep(s, output)
    return sel(conf.dc == "gdc", f"-M -MF $s -MT $output", f"-makedeps=$s")
end

function version(s)
    return sel(conf.dc == "gdc", f"-fversion=$s", f"-d-version=$s")
end

function noobj()
    return sel(conf.dc == "gdc", "-fsyntax-only", "-c -o-")
end

function nopattern()
    return sel(conf.dc == "gdc", "-fno-tree-loop-distribute-patterns", "-disable-simplify-libcalls")
end

local opt = getopt(conf.profile)

local machine = machines[conf.board]
if machine == nil then
    error("invalid board: " .. conf.board)
end

local objdir = f".build/$(machine.board)/obj"
local depdir = f".build/$(machine.board)/dep"

local prefix = machine.triple

tools = {
    ldc := ldc2
    gdc := $prefix-gdc
    cc := $prefix-gcc
    as := $prefix-as
    ld := $prefix-ld
    objcopy := $prefix-objcopy
    objdump := $prefix-objdump
    ar := $prefix-ar
    strip := $prefix-strip
    gdb := gdb-multiarch
    qemu = machine.qemu,
}

tools.dc = sel(conf.dc == "gdc", tools.gdc, tools.ldc)

function gnu(machine)
    local f = {
        aarch64 := -march=$(machine.march) -mcpu=$(machine.mcpu) $(machine.mflags)
        riscv64 := -march=$(machine.march) -mcmodel=$(machine.mcmodel) -mabi=$(machine.mabi) $(machine.mflags)
    }
    return f[machine.arch]
end

function llvm(machine)
    local f = {
        aarch64 := -mtriple=$(machine.triple) -mcpu=$(machine.mcpu) -mattr=$(machine.mattr)
        riscv64 := -mtriple=$(machine.triple) -mattr=$(machine.mattr) -code-model=$(machine.cmodel) -mabi=$(machine.mabi)
    }
    return f[machine.arch]
end

function gdc(machine)
    return f"$(gnu(machine)) -$(opt.level) -ffunction-sections -fdata-sections -nophoboslib -fno-exceptions -fno-moduleinfo -fno-rtti -g -Wframe-larger-than=1024 -Wall -Werror -nostdinc -ftransition=tls $(version(machine.board)) -Wno-builtin-declaration-mismatch"
end

function ldc(machine)
    return f"$(llvm(machine)) -betterC -$(opt.level) -g -function-sections -data-sections -fvisibility=hidden $(version(machine.board))"
end

local incdi := -I$depdir/src -I$depdir/lib
local inc := -Isrc -Ilib

local flags = {
    gnu := $(gnu(machine))
    llvm := $(llvm(machine))
    gdc := $(gdc(machine)) $(inc)
    ldc := $(ldc(machine)) $(inc)
    cc := $(gnu(machine)) -$(opt.level)
    as := $(gnu(machine))
    qemu := -nographic -no-reboot
    objdump := -j .text -j .data -j .rodata -j .bss -j .stack -j .heap -j .payload -d
}
flags.dc = sel(conf.dc == "gdc", flags.gdc, flags.ldc)

local src = {}

function src.kernplix()
    return knit.join(
        knit.glob(f"src/plix/arch/$(machine.arch)/*.d"),
        knit.glob(f"src/plix/arch/*.d"),
        knit.rglob("src/plix/dev", "*.d"),
        knit.rglob("src/plix/alloc", "*.d"),
        knit.glob("src/plix/*.d"),
        {
            f"src/plix/board/$(machine.board).d",
            "src/plix/board/package.d",
        }
    )
end

function src.core()
    return knit.rglob("lib/core", "*.d")
end

function src.boot()
    return knit.glob("src/boot/*.d")
end

local asm = {}

function asm.kernplix()
    return knit.join(
        knit.glob(f"src/plix/arch/$(machine.arch)/*.s")
    )
end

function asm.boot()
    return knit.glob(f"src/boot/arch/$(machine.arch)/*.s")
end

function di(srcs)
    if conf.unified then
        return {}
    end
    return knit.prefix(knit.extrepl(srcs, ".d", ".di"), depdir .. "/")
end

function getobj(src, asm, pkg)
    if not conf.unified then
        return knit.join(
            knit.prefix(knit.extrepl(src, ".d", ".o"), objdir .. "/"),
            knit.prefix(knit.extrepl(asm, ".s", ".asm.o"), objdir .. "/")
        )
    else
        return knit.join(
            {objdir .. "/" .. pkg .. ".o"},
            knit.prefix(knit.extrepl(asm, ".s", ".asm.o"), objdir .. "/")
        )
    end
end

local obj = {
    kernplix = getobj(src.kernplix(), asm.kernplix(), "plix"),
    boot = getobj(src.boot(), asm.boot(), "boot"),
    core = getobj(src.core(), {}, "core"),
}

local extraobj := $objdir/lib/builtins.o $objdir/lib/object.o

local link = {
    kernel = f"link/$(conf.board)/kernel.ld",
    boot = f"link/$(conf.board)/boot.ld",
}

local plboot = {
    bin = "tools/plboot/plboot",
    src = knit.glob("tools/plboot/*.go"),
}

local o = sel(conf.dc == "gdc", "o", "of")

return b{
    $ all:VB: kernel.boot.elf

    $ libplix.a: $objdir/libplix.a
        mv $input $output

    $ kernel.boot.elf: $(obj.boot) $objdir/libplix.a $(link.boot)[I]
        $(tools.cc) $(flags.gnu) -Wl,--gc-sections -T$(link.boot) -nostdinc -nostdlib $input -lgcc -o $output

    $ $objdir/libplix.a: $(obj.kernplix) $(obj.core) $extraobj
        rm -f $output
        $(tools.ar) -rc $output $input
    $ $objdir/libboot.a: $(obj.boot)
        rm -f $output
        $(tools.ar) -rc $output $input

    $ $depdir/%.di: %.d
        $(tools.dc) $(flags.dc) $(noobj()) -Hf $output $input

    $ $objdir/core.o: $(src.core())
        $(tools.dc) $(flags.dc) -c $input -$o $output
    $ $objdir/plix.o: $(src.kernplix()) [[$(src.core())]][I]
        $(tools.dc) $(flags.dc) -c $input -$o $output
    $ $objdir/boot.o: $(src.boot()) [[$(src.core()) $(src.kernplix())]][I]
        $(tools.dc) $(flags.dc) -c $input -$o $output
    $ $objdir/lib/builtins.o: lib/builtins.d
        $(tools.dc) $(flags.dc) -c $input -$o $output $(nopattern())

    $ $objdir/%.o:D[$depdir/%.dep]: %.d [[$(di(src.core())) $(di(src.kernplix())) $(di(src.boot()))]][I]
        $(tools.dc) $(incdi) $(flags.dc) $(makedep(dep, output)) -c $input -$o $output
    $ $objdir/%.asm.o: %.s
        $(tools.cc) $(flags.as) $input -c -o $output

    $ %.list: %.elf
        $(tools.objdump) $(flags.objdump) $input > $output
    $ %.bin: %.elf
        $(tools.objcopy) $input -O binary $output
    $ %.img: %.bin
        vf2-imager -i $input -o $output
    $ qemu:VB: kernel.boot.elf
        $(tools.qemu) $(flags.qemu) -kernel $input
    $ qemu-gdb:VB: kernel.boot.elf kernel.boot.elf
        $(tools.qemu) $(flags.qemu) -kernel $(inputs[1]) -s -S &
        $(tools.gdb) -ex "file $(inputs[2])" -ex "target remote localhost:1234"

    $ lint:VB:
        dscanner --styleCheck $(src.core()) $(src.kernplix()) $(src.boot()) --config .dscanner.ini -I. -Ilibd --errorFormat '{filepath}({line},{column}): Error: [{type}] {message}'
}
