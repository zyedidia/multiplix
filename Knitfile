knit = require("knit")

local _, uconf = pcall(include, "build/conf.knit")

conf = {
    board = choose(cli.board, uconf.board, "virt_riscv64"),
    lto = choose(tobool(cli.lto), uconf.lto, false),
    release = choose(tobool(cli.release), uconf.release, false),
    unified = choose(tobool(cli.unified), uconf.unified, true),
    dc = choose(cli.dc, uconf.dc, "ldc2"),
    sanitize = choose(tobool(cli.san), tobool(cli.sanitize), uconf.sanitize, false),
    stackprot = choose(tobool(cli.stackprot), uconf.stackprot, false),
    analyzer = choose(tobool(cli.analyzer), uconf.analyzer, false),
    test = choose(tobool(cli.test), uconf.test, false),
    check = choose(tobool(cli.check), uconf.check, false),
}

of = sel(conf.dc == "gdc", "o", "of")

build = include("build/build.knit")

function dversion(s)
    local vflag = sel(conf.dc == "gdc", "-fversion", "-d-version")
    return f"$vflag=$s"
end

function makedeps(s, output)
    return sel(conf.dc == "gdc", f"-M -MF $s -MT $output", f"-makedeps=$s")
end

build = include("build/build.knit")

local monitor = false
local machine = build.machine(conf.board, monitor)
if machine == nil then
    return "could not find machine for board " .. conf.board
end

local tools = build.tools(machine)
local flags = build.flags(machine, conf.lto, conf.release, monitor)

local plboot = {
    bin = "tools/plboot/plboot",
    src = knit.glob("tools/plboot/*.go"),
}

local meta = r{
    $ .kobj/libd/libc.o:D[.kobj/deps/libd/libc.dep]: libd/libc.d
        $(tools.dc) $(flags.dc_libc) -Ilibd $input -c -$of $output $(makedeps(f".kobj/deps/libd/libc.dep", output))
    $ .kobj/%.o: %.s
        $(tools.cc) $(flags.as) $input -c -o $output
    $ .kobj/%.o:D[.kobj/deps/%.dep]: %.d
        $(tools.dc) $(flags.dc) -I. -Ilibd $input -c -$of $output $(makedeps(f".kobj/deps/$match.dep", output))
    $ %.bin: %.elf
        $(tools.objcopy) $input -O binary $output
    $ %.bin.out: %.bin
        ./firmware/visionfive/fsz.sh $input $output
    $ %.payload: %.elf $(plboot.bin)[I]
        ./$(plboot.bin) make -o $output $input
    $ %.list: %.elf
        $(tools.objdump) -D $input > $output
    $ %.img: %.bin
        vf2-imager -i $input -o $output
}

local src = {}
local obj = {}

function src.libd()
    return knit.filterout(knit.rglob("libd", "*.d"), {"libd/libc.d"})
end

function src.libkern()
    return knit.join(
        knit.glob(f"kernel/arch/$(machine.arch)/*.d"),
        knit.rglob("kernel/dev", "*.d"),
        knit.rglob("kernel/alloc", "*.d"),
        knit.rglob("kernel/fs", "*.d"),
        knit.rglob("kernel/check", "*.d"),
        knit.filterout(knit.glob("kernel/*.d"), {"kernel/main.d"}),
        {
            "kernel/arch/package.d",
            "kernel/board/package.d",
            f"kernel/board/$(machine.board).d",
        }
    )
end

function src.kernel()
    return knit.join(src.libd(), src.libkern(), {"kernel/main.d"})
end

function src.libmonitor()
    return knit.join(
        knit.glob(f"kernel/arch/$(machine.arch)/monitor/*.d"),
        src.libkern(),
        src.libd()
    )
end

function src.monitor()
    return knit.join(src.libd(), src.libmonitor, {"bootloader/main.d"})
end

function obj.kasm()
    return knit.prefix({
        f"kernel/arch/$(machine.arch)/kernelasm.o",
        f"kernel/arch/$(machine.arch)/userasm.o",
        "libd/libc.o",
    }, ".kobj/")
end

function obj.masm()
    return knit.prefix({
        f"kernel/arch/$(machine.arch)/monitor/monitorasm.o",
        "libd/libc.o",
    }, ".bootobj/")
end

function obj.kernel()
    return knit.join(
        knit.prefix(knit.extrepl(src.kernel(), ".d", ".o"), ".kobj/"),
        obj.kasm()
    )
end

function obj.libmonitor()
    return knit.join(
        knit.prefix(knit.extrepl(src.libmonitor(), ".d", ".o"), ".bootobj/"),
        obj.masm()
    )
end

local link = {
    kernel = f"link/$(machine.board)/kernel.ld",
}

local kernel
if conf.unified then
    kernel = r{
        $ .kobj/kernel.o: $(src.kernel()) user/hello/hello.elf[I]
            $(tools.dc) $(flags.dc) -I. -Ilibd $input -c -$of $output
        $ kernel.elf: .kobj/kernel.o $(obj.kasm()) coremark/libcoremark.a $(link.kernel)[I]
            $(tools.ld) -T$(link.kernel) $input -o $output $(flags.ld)
    }
else
    kernel = r{
        $ kernel.elf: $(obj.kernel()) coremark/libcoremark.a $(link.kernel)[I]
            $(tools.ld) -T$(link.kernel) $input -o $output $(flags.ld)
        $ .kobj/kernel/main.o: user/hello/hello.elf
    }
end

local allsrc = knit.rglob(".", "*.d")

local bootloader = dofile("build/bootloader.knit")

return b{
    $ all:V: kernel.boot.elf

    $ comp:V: kernel.boot.bin $(knit.prefix(allsrc, "lint-"))

    $ qemu:VB: kernel.boot.elf
        $(tools.qemu) $(flags.qemu) -no-reboot -kernel $input
    $ qemu-gdb:VB: kernel.boot.elf
        $(tools.qemu) $(flags.qemu) -no-reboot -s -S -kernel $input &
        $(tools.gdb) -ex "file kernel.elf" -ex "target remote localhost:1234"

    $ coremark/libcoremark.a:VB:
        make -C coremark PORT_DIR=multiplix TIMER_FREQ=100000 -B

    $ format:VB:
        dfmt -i --brace_style=otbs $allsrc

    $ clean:VB:
        knit :all -t clean
        rm -rf *.list *.bin *.bin.out

    $ prog:VB: kernel.elf $(plboot.bin)[I]
        ./$(plboot.bin) prog $input

    $ $(plboot.bin): $(plboot.src)
        cd tools/plboot && go build

    $ lint:VB:
        dscanner --styleCheck $allsrc --config .dscanner.ini -I. -Ilibd --errorFormat '{filepath}({line},{column}): Error: [{type}] {message}'

    $ lint-%:VB: %
        dscanner --styleCheck $input --config .dscanner.ini -I. -Ilibd --errorFormat '{filepath}({line},{column}): Error: [{type}] {message}'

    include("user/hello/build.knit"),

    bootloader.meta(),
    bootloader.rules("kernel.boot.elf", "kernel.payload", conf.unified),
    bootloader.rules("bootloader.elf", nil, conf.unified),

    include("firmware/raspi/build.knit"),

    kernel,
    meta
}
