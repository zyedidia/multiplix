local build = {}

function build.prefix(arch)
    local prefixes = {
        aarch64 = "aarch64-none-elf",
        riscv64 = "riscv64-unknown-elf",
    }
    return prefixes[arch]
end

function build.machine(board, monitor)
    local align_attr = sel(monitor, "+strict-align", "")
    local malign = sel(monitor, "-mstrict-align", "")
    local machines = {
        raspi3 = {
            board = "raspi3",
            march = "armv8-a+crc",
            mcpu = "cortex-a53",
            mattr = f"$align_attr,-sve,-fp-armv8",
            mflags = f"-mgeneral-regs-only $malign",
            arch = "aarch64",
            qemu = "-M raspi3ap -serial null -serial mon:stdio",
        },
        raspi4 = {
            board = "raspi4",
            march = "armv8-a+crc",
            mcpu = "cortex-a72",
            mattr = f"$align_attr,-sve,-fp-armv8",
            mflags = f"-mgeneral-regs-only $malign",
            arch = "aarch64",
            qemu = "-M raspi4b -serial null -serial mon:stdio" -- doesn't exist
        },
        virt_aarch64 = {
            board = "virt_aarch64",
            march = "armv8-a+crc",
            mcpu = "cortex-a72",
            mattr = f"$align_attr,-sve,-fp-armv8",
            mflags = f"-mgeneral-regs-only $malign",
            arch = "aarch64",
            qemu = "-M virt -smp 4 -m 2G -cpu cortex-a72 -machine virtualization=true"
        },
        visionfive = {
            board = "visionfive",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M visionfive -bios none -smp 2 -m 2G", -- doesn't exist
        },
        visionfive2 = {
            board = "visionfive2",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M visionfive2 -bios none -smp 4 -m 2G", -- doesn't exist
        },
        virt_riscv64 = {
            board = "virt_riscv64",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M virt -bios none -smp 4 -m 2G",
        }
    }
    local m = machines[board]
    if m == nil then
        return nil
    end
    if m.mcmodel == "medany" then
        m.cmodel = "medium"
    else
        m.cmodel = "small"
    end
    return m
end

function build.tools(machine)
    local prefix = build.prefix(machine.arch)
    return {
        dc = sel(conf.dc == "gdc", f"$prefix-gdc", "ldc2"),
        ldc := ldc2
        gdc := $prefix-gdc
        cc := $prefix-gcc
        as := $prefix-as
        ld := $prefix-gcc
        cpp := $prefix-cpp
        objcopy := $prefix-objcopy
        objdump := $prefix-objdump
        strip := $prefix-strip
        gdb := gdb-multiarch
        qemu := qemu-system-$(machine.arch)
    }
end

function build.flags_llvm(machine)
    local prefix = build.prefix(machine.arch)

    local flags = {
        aarch64 := -mtriple=$prefix -mcpu=$(machine.mcpu) -mattr=$(machine.mattr)
        riscv64 := -mtriple=$prefix -mattr=$(machine.mattr) -code-model=$(machine.cmodel) -mabi=$(machine.mabi)
    }
    return flags[machine.arch]
end

function build.flags_gnu(machine)
    local flags = {
        aarch64 := -march=$(machine.march) -mcpu=$(machine.mcpu)
        riscv64 := -march=$(machine.march) -mcmodel=$(machine.mcmodel) -mabi=$(machine.mabi)
    }
    return flags[machine.arch]
end

function build.flags_compiler(monitor, machine)
    vmon = sel(monitor, "monitor", "kernel")

    local flags = {
        gnu = build.flags_gnu(machine),
        llvm = build.flags_llvm(machine),
    }

    local san = sel(conf.sanitize and not monitor, "-fsanitize=kernel-address,undefined -fno-wrapv -fversion=sanitizer", "")
    local stackprot = sel(conf.stackprot, "-fstack-protector-all", "")
    local analyzer = sel(conf.analyzer, "-fanalyzer -Wno-analyzer-va-arg-type-mismatch -Wno-analyzer-va-list-exhausted", "")
    local unittest = sel(conf.test, sel(conf.dc == "gdc", "-funittest", "-unittest"), "")
    local check = sel(conf.check, dversion("check"), "")

    local gnu_extra := $san $stackprot -Wframe-larger-than=1024 -Wall -Werror

    local compiler = {
        gdc := $(flags.gnu) -nophoboslib -fno-exceptions -fno-moduleinfo -fno-rtti -O3 -g -ffunction-sections -fdata-sections -fversion=$vmon -fversion=$(machine.board) -J. -fno-tree-loop-distribute-patterns $(machine.mflags) $gnu_extra -ftransition=tls $analyzer $unittest $check
        ldc2 := $(flags.llvm) -betterC -O3 -g -function-sections -data-sections -fthread-model=global-dynamic -fvisibility=hidden -d-version=$vmon -d-version=$(machine.board) -J. $unittest $check
        ldgcc := $(flags.gnu) $gnu_extra
    }
    return compiler
end

function build.flags(machine, lto, release, monitor)
    local prefix = build.prefix(machine.arch)
    local knit = require("knit")

    local ldlto = ""
    local dclto = ""
    if lto then
        if conf.dc == "gdc" and lto then
            dclto := -flto
            ldlto := -flto
        else
            local ltoplugin = knit.shell("dirname $(which ldc2)") .. "/../lib/LLVMgold-ldc.so"
            dclto := -flto=full
            ldlto := -Wl,-plugin=$ltoplugin -Wl,-plugin-opt=O2 -Xlinker -plugin-opt=-mattr=$(machine.mattr)
            if machine.arch == "riscv64" then
                ldlto = ldlto .. f" -Wl,-plugin-opt=-code-model=$(machine.cmodel)"
            end
        end
    end

    local compiler = build.flags_compiler(monitor, machine)
    local flags = {
        llvm = build.flags_llvm(machine),
        gnu = build.flags_gnu(machine),
        dc = compiler[conf.dc],
        ldgcc = compiler["ldgcc"],
    }

    return {
        dc := $(flags.dc) $dclto
        dc_libc := $(flags.dc) $(sel(conf.dc ~= "gdc", dclto, ""))
        cc := -Os $(flags.gnu)
        as := -Os $(flags.gnu) -xassembler-with-cpp
        ld := $ldlto -Wl,--gc-sections -nostdlib -nostartfiles -lgcc $(flags.gnu) $(flags.ldgcc)
        qemu := $(machine.qemu) -nographic
    }
end

return build
