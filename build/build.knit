local build = {}

function build.prefix(arch)
    local prefixes = {
        aarch64 = "aarch64-none-elf",
        riscv64 = "riscv64-unknown-elf",
    }
    return prefixes[arch]
end

function build.machine(board, monitor)
    local tpidr = sel(conf.dc == "gdc", sel(monitor, "el2", "el1"), sel(monitor, "tpidr-el2", "tpidr-el1"))
    local machines = {
        raspi3 = {
            board = "raspi3",
            march = "armv8-a+crc",
            mcpu = "cortex-a53",
            mattr = f"+strict-align,+$tpidr,-sve,-fp-armv8",
            mflags = f"-mtp=$tpidr -mgeneral-regs-only",
            arch = "aarch64",
            qemu = "-M raspi3ap -serial null -serial mon:stdio",
        },
        raspi4 = {
            board = "raspi4",
            march = "armv8-a+crc",
            mcpu = "cortex-a72",
            mattr = f"+strict-align,+$tpidr,-sve,-fp-armv8",
            mflags = f"-mtp=$tpidr -mgeneral-regs-only",
            arch = "aarch64",
            qemu = "-M raspi4b -serial null -serial mon:stdio" -- doesn't exist
        },
        visionfive = {
            board = "visionfive",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M visionfive -bios none -smp 2 -m 2G", -- doesn't exist
        },
        visionfive2 = {
            board = "visionfive2",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M visionfive2 -bios none -smp 4 -m 2G", -- doesn't exist
        },
        virt_riscv64 = {
            board = "virt_riscv64",
            mabi = "lp64",
            march = "rv64imac_zicsr_zifencei",
            mattr = "+m,+a,+c,+relax",
            mflags = "",
            arch = "riscv64",
            mcmodel = "medany",
            qemu = "-M virt -bios none -smp 4 -m 2G",
        }
    }
    local m = machines[board]
    if m == nil then
        return nil
    end
    if m.mcmodel == "medany" then
        m.cmodel = "medium"
    else
        m.cmodel = "small"
    end
    return m
end

function build.tools(machine)
    local prefix = build.prefix(machine.arch)
    return {
        dc = sel(conf.dc == "gdc", f"$prefix-gdc", "ldc2"),
        ldc := ldc2
        gdc := $prefix-gdc
        cc := $prefix-gcc
        as := $prefix-as
        ld := $prefix-gcc
        cpp := $prefix-cpp
        objcopy := $prefix-objcopy
        objdump := $prefix-objdump
        strip := $prefix-strip
        gdb := gdb-multiarch
        qemu := qemu-system-$(machine.arch)
    }
end

function build.flags_llvm(machine)
    local prefix = build.prefix(machine.arch)

    local flags = {
        aarch64 := -mtriple=$prefix -mcpu=$(machine.mcpu) -mattr=$(machine.mattr)
        riscv64 := -mtriple=$prefix -mattr=$(machine.mattr) -code-model=$(machine.cmodel)
    }
    return flags[machine.arch]
end

function build.flags_gnu(machine)
    local flags = {
        aarch64 := -march=$(machine.march) -mcpu=$(machine.mcpu)
        riscv64 := -march=$(machine.march) -mcmodel=$(machine.mcmodel) -mabi=$(machine.mabi)
    }
    return flags[machine.arch]
end

function build.flags_dc(dc, monitor, machine)
    vmon = sel(monitor, "monitor", "kernel")

    local flags = {
        gnu = build.flags_gnu(machine),
        llvm = build.flags_llvm(machine),
    }

    local compiler = {
        gdc := $(flags.gnu) -nophoboslib -fno-exceptions -fno-moduleinfo -fno-rtti -Os -ffunction-sections -fdata-sections -fversion=$vmon -fversion=$(machine.board) -J. -fno-tree-loop-distribute-patterns $(machine.mflags) -Wall -Werror
        ldc2 := $(flags.llvm) -betterC -Oz -function-sections -data-sections -fthread-model=local-exec -fno-plt -fvisibility=hidden -d-version=$vmon -d-version=$(machine.board) -J.
    }
    return compiler[dc]
end

function build.flags(machine, lto, release, monitor)
    -- LTO currently disabled due to difficulties setting up a flow that can handle
    -- both GDC and LDC
    if lto then
        print("warning: lto is currently required to be disabled")
    end
    lto = false
    -- if conf.dc == "gdc" and lto then
        -- print("warning: gdc and lto cannot currently be used together")
    -- end

    local prefix = build.prefix(machine.arch)
    local knit = require("knit")
    local version = sel(monitor, "-d-version=monitor", "-d-version=kernel")
    local ltoplugin = knit.shell("dirname $(which ldc2)") .. "/../lib/LLVMgold-ldc.so"
    local flto = sel(lto, "-flto=full", "")
    -- problem: if we use gcc as the linker then we have to pass -Wl,-plugin-opt=-mattr=+x,+y,+z
    -- and gcc disallows commas in a -Wl command
    local ltoflags := -plugin=$ltoplugin -plugin-opt=O2 -plugin-opt=-mattr=$(machine.mattr)
    if machine.arch == "riscv64" then
        ltoflags = ltoflags .. f" -plugin-opt=-code-model=$(machine.cmodel)"
    end
    ltoflags = sel(lto, ltoflags, "")

    local flags = {
        llvm = build.flags_llvm(machine),
        gnu = build.flags_gnu(machine),
        dc = build.flags_dc(conf.dc, monitor, machine)
    }

    return {
        dc := $(flags.dc) $flto
        cc := -Os $(flags.gnu)
        as := -Os $(flags.gnu) -xassembler-with-cpp
        ld := -Wl,--gc-sections -nostdlib -nostartfiles -lgcc $(flags.gnu)
        qemu := $(machine.qemu) -nographic
    }
end

return build
