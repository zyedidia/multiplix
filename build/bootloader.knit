local machine = build.machine(conf.board, true)
local bootloader = {
    tools = build.tools(machine),
    flags = build.flags(machine, conf.lto, conf.release, true)
}

function bootloader.meta()
    local flags = bootloader.flags
    local tools = bootloader.tools

    return r{
        $ .bootobj/%.o: %.s
            $(tools.cc) $(flags.as) $input -c -o $output
        $ .bootobj/%.o:D[.bootobj/deps/%.dep]: %.d
            $(tools.dc) $(flags.dc) -Ikernel -Ilibd $input -c -of $output -makedeps=.bootobj/deps/$match.dep
    }
end

function bootloader.rules(bootelf, payload)
    local version = sel(payload == nil, "uart", "payload")

    local objects = knit.join(obj.libmonitor(), {
        f".bootobj/bootloader/main-$version.o",
    })

    if payload ~= nil then
        objects = knit.join(objects, {".bootobj/bootloader/payload.o"})
    else
        payload = ""
    end

    local link = f"link/$(machine.board)/bootloader.ld"

    local rules = b{
        $ .bootobj/bootloader/main-$version.o:D[.bootobj/deps/bootloader/main.dep]: bootloader/main.d
            $(tools.dc) $(flags.dc) -Ikernel -Ilibd $input -c -of $output -makedeps=.bootobj/deps/bootloader/main.dep -d-version=$version
        $ $bootelf: $(objects) $(link)[I]
            $(tools.ld) $(flags.ld) -T$(link) $input -o $output
    }

    if payload ~= "" then
        rules = rules +
            $ .bootobj/bootloader/payload.o: bootloader/payload.s $(payload)
                $(tools.cc) $(flags.as) -c -o $output $(inputs[1]) -DPAYLOAD=$(payload)
    end

    return rules
end

return bootloader
